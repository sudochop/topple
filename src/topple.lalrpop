use crate::{
    tokens::Token,
    lexer::LexicalError,
    ast::*,
};

use lalrpop_util::ErrorRecovery;

grammar<'input, 'err>(input: &'input str, errors: &'err mut Vec<ErrorRecovery<usize, Token, LexicalError>>);

pub SourceUnit: SourceUnit = {
    Declaration* => SourceUnit { declarations: <> }
}

Declaration: Declaration = {
    <l:@L> <name:"funcname"> "{" <exprs:Expr*> "}" <r:@R> => Declaration {
        location: (l, r),
        node: DeclarationKind::Function {
            name,
            exprs,
        }
    }
}

Expr: Expr = {
    <l:@L> "if" "{" <then_exprs:Expr*> "}" <maybe_else_exprs:Else?> <r:@R> => Expr {
        location: (l, r),
        node: ExprKind::Conditional { then_exprs, maybe_else_exprs }
    },
    <l:@L> "while" <while_exprs:Expr2*> "{" <do_exprs:Expr*> "}" <r:@R> => Expr {
        location: (l, r),
        node: ExprKind::While { while_exprs, do_exprs }
    },
    <Expr2> => <>,
}

Else: Vec<Expr> = {
   <l:@L> "else" "{" <ops:Expr*> "}" <r:@R> => ops, 
}

Expr2: Expr = {
    <l:@L> <expr:Expr3> <r:@R> => Expr {
        location: (l, r),
        node: expr,
    }
}

Expr3: ExprKind = {
    "integer" => ExprKind::Integer(<>),

    "==" => ExprKind::Eq,
    ">=" => ExprKind::Gte,
    "<=" => ExprKind::Lte,
    ">" => ExprKind::Gt,
    "<" => ExprKind::Lt,

    "or" => ExprKind::Or,

    "+" => ExprKind::Add,
    "-" => ExprKind::Sub,
    "*" => ExprKind::Mul,
    "/" => ExprKind::Div,

    "putchar" => ExprKind::Putchar,
    "putint" => ExprKind::Putint,
    "dbg" => ExprKind::Dbg,

    "dup" => ExprKind::Dup,
    "swap" => ExprKind::Swap,
    "over" => ExprKind::Over,
    "rot" => ExprKind::Rot,

    "drop" => ExprKind::Drop,

    "mem" => ExprKind::Mem,
    "store" => ExprKind::Store,
    "load" => ExprKind::Load,

    "funcname" => ExprKind::FnCall(<>),
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "if" => Token::If,
        "else" => Token::Else,
        "while" => Token::While,

        "{" => Token::LCurlyBracket,
        "}" => Token::RCurlyBracket,
        
        "integer" => Token::Integer(<u64>),

        "==" => Token::Eq,
        ">=" => Token::Gte,
        "<=" => Token::Lte,
        ">" => Token::Gt,
        "<" => Token::Lt,

        "or" => Token::Or,

        "+" => Token::Add,
        "-" => Token::Sub,
        "*" => Token::Mul,
        "/" => Token::Div,

        "putchar" => Token::PutChar,
        "putint" => Token::PutInt,
        "dbg" => Token::Dbg,

        "dup" => Token::Dup,
        "swap" => Token::Swap,
        "over" => Token::Over,
        "rot" => Token::Rot,

        "drop" => Token::Drop,

        "mem" => Token::Mem,
        "store" => Token::Store,
        "load" => Token::Load,

        "funcname" => Token::FnName(<String>),
    }
}