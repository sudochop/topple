use crate::{
    tokens::Token,
    lexer::LexicalError,
    ast::*,
};

use lalrpop_util::ErrorRecovery;

grammar<'input, 'err>(input: &'input str, errors: &'err mut Vec<ErrorRecovery<usize, Token, LexicalError>>);

pub SourceUnit: SourceUnit = {
    Declaration* => SourceUnit { declarations: <> }
}

Block: Block = {
    <l:@L> "{" <exprs:Expr*> "}" <r:@R> => Block {
        location: (l, r),
        node: BlockKind {
            exprs,
        }
    }
}

Declaration: Declaration = {
    <l:@L> "include" <path:"string"> <r:@R> => Declaration {
        location: (l, r),
        node: DeclarationKind::Include(path)
    },
    <l:@L> "fn" <name:"bareword"> <body:Block> <r:@R> => Declaration {
        location: (l, r),
        node: DeclarationKind::Function {
            name,
            body,
        }
    },
    <l:@L> "macro!" <name:"bareword"> "[" <args:Binding*> "]" <body:Block> <r:@R> => Declaration {
        location: (l, r),
        node: DeclarationKind::Macro(Macro {
            name,
            args,
            body,
        })
    },
    <l:@L> "macro!" <name:"integer"> "[" <args:Binding*> "]" <body:Block> <r:@R> => Declaration {
        location: (l, r),
        node: DeclarationKind::Macro(Macro {
            name: name.to_string(),
            args,
            body,
        })
    },
    <l:@L> "macro!" <name:"bareword"> <body:Block> <r:@R> => Declaration {
        location: (l, r),
        node: DeclarationKind::Macro(Macro {
            name,
            args: vec![],
            body,
        })
    },
}

Binding: String = {
    "binding" => <>
}

Expr: Expr = {
    <l:@L> "if" <then_block:Block> <maybe_else_block:Else?> <r:@R> => Expr {
        location: (l, r),
        node: ExprKind::Conditional { then_block, maybe_else_block }
    },
    <l:@L> "while" <while_exprs:Expr2*> <do_block:Block> <r:@R> => Expr {
        location: (l, r),
        node: ExprKind::While { while_exprs, do_block }
    },
    <l:@L> <block:Block> <r:@R> => Expr {
        location: (l, r),
        node: ExprKind::Block(block)
    },
    <Expr2> => <>,
}

Else: Block = {
   <l:@L> "else" <block:Block> <r:@R> => block, 
}

Expr2: Expr = {
    <l:@L> <expr:Expr3> <r:@R> => Expr {
        location: (l, r),
        node: expr,
    },
}

Expr3: ExprKind = {
    "integer" => ExprKind::Integer(<>),
    "string" => ExprKind::String(<>),

    "==" => ExprKind::Eq,
    ">=" => ExprKind::Gte,
    "<=" => ExprKind::Lte,
    ">" => ExprKind::Gt,
    "<" => ExprKind::Lt,

    "or" => ExprKind::Or,

    "+" => ExprKind::Add,
    "-" => ExprKind::Sub,
    "*" => ExprKind::Mul,
    "/" => ExprKind::Div,

    "putchar" => ExprKind::Putchar,
    "putint" => ExprKind::Putint,
    "dbg" => ExprKind::Dbg,

    "dup" => ExprKind::Dup,
    "swap" => ExprKind::Swap,
    "over" => ExprKind::Over,
    "rot" => ExprKind::Rot,
    "drop" => ExprKind::Drop,
    "fetch" => ExprKind::Fetch,

    "mem" => ExprKind::Mem,
    "store" => ExprKind::Store,
    "load" => ExprKind::Load,

    "bareword" => ExprKind::FnCall(<>),

    <name:"macrocall"> "[" <args:Expr*> "]" => ExprKind::MacroCall {
        name,
        args,
    },
    <name:"macrocall"> => ExprKind::MacroCall {
        name,
        args: vec![],
    },

    "binding" => ExprKind::Binding(<>),
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "if" => Token::If,
        "else" => Token::Else,
        "while" => Token::While,

        "{" => Token::LCurlyBracket,
        "}" => Token::RCurlyBracket,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        
        "integer" => Token::Integer(<u64>),
        "string" => Token::LiteralString(<String>),

        "==" => Token::Eq,
        ">=" => Token::Gte,
        "<=" => Token::Lte,
        ">" => Token::Gt,
        "<" => Token::Lt,

        "or" => Token::Or,

        "+" => Token::Add,
        "-" => Token::Sub,
        "*" => Token::Mul,
        "/" => Token::Div,

        "putchar" => Token::PutChar,
        "putint" => Token::PutInt,
        "dbg" => Token::Dbg,

        "dup" => Token::Dup,
        "swap" => Token::Swap,
        "over" => Token::Over,
        "rot" => Token::Rot,
        "drop" => Token::Drop,
        "fetch" => Token::Fetch,

        "mem" => Token::Mem,
        "store" => Token::Store,
        "load" => Token::Load,

        "fn" => Token::Fn,
        "bareword" => Token::BareWord(<String>),

        "macro!" => Token::MacroDef,
        "macrocall" => Token::MacroCall(<String>),

        "binding" => Token::Binding(<String>),

        "include" => Token::Include,
    }
}